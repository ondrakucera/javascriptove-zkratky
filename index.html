<!DOCTYPE html>
<html lang="cs">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Javascriptové zkratky</title>
		<link href="prism.css" rel="stylesheet"/>
		<link href="style.css" rel="stylesheet"/>
		<script src="index.js"></script>
	</head>
	<body class="line-numbers">
		<h1>Javascriptové zkratky</h1>

		<p>Tato stránka slouží jako rozšiřující materiál k javascriptovým kurzům pořádaným <a
		href="https://www.czechitas.cz/">Czechitas</a> nebo <a href="https://reactgirls.com/">ReactGirls</a>. Na nich
		dáváme důraz především na naprostou srozumitelnost prezentovaných ukázek, i za cenu o něco delšího
		zápisu. Zároveň vždy není dostatek času ke každé konstrukci ukázat nebo dostatečně procvičit všechny
		alternativní zápisy. V pozdější praxi (nebo při studiu materiálů jiných autorů) však každý na ony zkrácené
		varianty dříve či později narazí. Cílem této stránky je tedy shrnout nejběžnější takovéto momenty.</p>

		<p>Každá sekce obsahuje stručný popis situace a následně dva ekvivalentní (pokud možno) bloky kódu. První z nich
		obsahuje zkrácenou variantu určitého zápisu, která nemusí být začátečníkům na první pohled zřejmá (zvláště v
		kontextu nějakého delšího programu), případně o ní nemuseli vždy vůbec slyšet. Druhý blok obsahuje týž kód
		rozepsán podrobněji tak, aby situaci vysvětloval.</p>

		<section id="template-literal">
			<h2>Šablony řetězců</h2>
			<p>Šablony se používají v situacích, kdy je potřeba vytvořit řetězec obsahující hodnoty nějakých proměnných
				(přesněji řečeno se v šabloně můžeme odkazovat na libovolný výraz, ale použití proměnných bývá
				nejčastější). Výsledek je podobný, jako kdybychom použili skládání řetězců operátorem <code>+</code>,
				pouze je použitý kód obvykle srozumitelnější.</p>
			<pre><code class="language-javascript">
const number1 = 3;
const number2 = 5;
const number3 = number1 + number2;
console.log(`Součet čísel ${number1} a ${number2} je ${number3}.`);
			</code></pre>
			<pre><code class="language-javascript">
const number1 = 3;
const number2 = 5;
const number3 = number1 + number2;
console.log("Součet čísel " + number1 + " a " + number2 + " je " + number3 + ".");
			</code></pre>
		</section>

		<section id="function-composition">
			<h2>Výsledek volání funkce jako argument volání další funkce</h2>
			<p>Často potřebujeme výsledek volání jedné funkce pouze k tomu, abychom jej předali funkci jiné. Mohli
				bychom si jej sice uložit do pomocné proměnné, ale pokud jej nepotřebujeme později ještě na něco jiného,
				obvykle se to nedělá.</p>
			<pre><code class="language-javascript">
const age = Number(prompt("Zadej věk:"));
			</code></pre>
			<pre><code class="language-javascript">
const ageString = prompt("Zadej věk:");
const age = Number(ageString);
			</code></pre>
		</section>

		<section id="arithmetic-assignment">
			<h2>Aritmetika s přiřazením</h2>
			<p>Pro situace, kdy potřebujeme k hodnotě určité číselné proměnné přičíst jiné číslo, existuje samostatný
				operátor. Podobně je tomu i pro další aritmetické operátory. Navíc stejného zápisu lze použít i pro
				spojování řetězců.</p>
			<pre><code class="language-javascript">
let number = 3;
number += 5; // 8
number -= 2; // 6
number *= 4; // 24
number /= 3; // 8
number %= 3; // 2
let string = "Hello";
string += " world!"; // "Hello world!"
			</code></pre>
			<pre><code class="language-javascript">
let number = 3;
number = number + 5; // 8
number = number - 2; // 6
number = number * 4; // 24
number = number / 3; // 8
number = number % 3; // 2
let string = "Hello";
string = string + " world!"; // "Hello world!"
			</code></pre>
		</section>

		<section id="increment-decrement">
			<h2>Inkrementace a dekrementace</h2>
			<p>Speciálním a velmi častým případem modifikace hodnoty číselné proměnné je její inkrementace nebo
				dekrementace, pro které tak vznikly samostatné operátory.</p>
			<pre><code class="language-javascript">
let number1 = 3;
let number2 = 2;
number1++; // 4
number2--; // 1
			</code></pre>
			<pre><code class="language-javascript">
let number1 = 3;
let number2 = 2;
number1 = number1 + 1; // 4
number2 -= 1; // 1
			</code></pre>
		</section>

		<section id="return-expression">
			<h2>Výraz jako návratová hodnota funkce</h2>
			<p>Návratovou hodnotu funkce není vždy potřeba si předem uložit do nějaké proměnné (jakkoliv je to často
				užitečné). Za klíčové slovo <code>return</code> je možné napsat jakýkoliv výraz.</p>
			<pre><code class="language-javascript">
function arithmeticMean(number1, number2) {
	return (number1 + number2) / 2;
}
			</code></pre>
			<pre><code class="language-javascript">
function arithmeticMean(number1, number2) {
	const result = (number1 + number2) / 2;
	return result;
}
			</code></pre>
		</section>

		<section id="boolean-return-expression">
			<h2>Vracení pravdivostních hodnot</h2>
			<p>Výsledky nejrůznějších porovnání jsou výrazy jako jakékoliv jiné a jejich výsledkem je pravdivostní
				hodnota. Tu můžeme tedy například přiřadit do libovolné proměnné. Jakkoliv i to se občas hodí, daleko
				častější je potřeba takovou hodnotu vrátit z funkce, kdy tedy není nutné tvořit okolo porovnání
				samostatnou podmínku a z ní explicitně vracet <code>true</code> nebo <code>false</code>.</p>
			<pre><code class="language-javascript">
function isOdd(number) {
	return number % 2 === 1;
}
			</code></pre>
			<pre><code class="language-javascript">
function isOdd(number) {
	if (number % 2 === 1) {
		return true;
	} else {
		return false;
	}
}
			</code></pre>
		</section>

		<section id="anonymous-function-assignment">
			<h2>Anonymní funkce přiřazená do proměnné</h2>
			<p>Funkce můžeme „pojmenovat“ rovněž trikem, kdy funkci vytvoříme jako anonymní, ale zároveň ji přiřadíme do
				nějaké proměnné (v naší ukázce do konstanty). Tento způsob používá málokdy, ale ukazuje důležitou
				vlastnost funkcí v JavaScriptu, totiž že funkce jsou obyčejnými hodnotami podobně jako třeba čísla nebo
				řetězce. Navíc naprosto stejný způsob se používá při zápisu funkcí tzv. šipkovou notací.</p>
			<pre><code class="language-javascript">
const greetUser = function (userName) {
	alert(`Hello, ${userName}!`);
}
			</code></pre>
			<pre><code class="language-javascript">
function greetUser(userName) {
	alert(`Hello, ${userName}!`);
}
			</code></pre>
		</section>

		<section id="arrow-function">
			<h2>Funkce definovaná šipkovou notací</h2>
			<p>Funkce můžeme zapisovat rovněž tzv. šipkovou notací.</p>
			<pre><code class="language-javascript">
const greetUser = (userName) =&gt; {
	alert(`Hello, ${userName}!`);
}
			</code></pre>
			<pre><code class="language-javascript">
function greetUser(userName) {
	alert(`Hello, ${userName}!`);
}
			</code></pre>
		</section>

		<section id="arrow-function-concise-body">
			<h2>Šipková funkce se zkráceným tělem</h2>
			<p>V případě, že šipková funkce ihned vrací nějakou hodnotu, nemusíme za šipku psát blok obsahující příkaz
				<code>return</code>. Stačí za šipku napsat pouze výraz vyjadřující návratovou hodnotu. Pozor je ovšem
				potřeba dát u šipkových funkcí se zkráceným tělem vracejících objekt: vracený objekt je potřeba umístit
				ještě do kulatých závorek (jinak by složené závorky nebyly považovány za začátek zápisu vraceného
				objektu, nýbrž za začátek bloku – nezkráceného těla funkce).</p>
			<pre><code class="language-javascript">
const arithmeticMean = (number1, number2) =&gt; (number1 + number2) / 2;
const means = (number1, number2) =&gt; ({
	arithmetic: (number1 + number2) / 2,
	geometric: Math.sqrt(number1 * number2),
	harmonic: 2 / (1 / number1 + 1 / number2)
});
			</code></pre>
			<pre><code class="language-javascript">
function arithmeticMean(number1, number2) {
	return (number1 + number2) / 2;
}
function means(number1, number2) {
	return {
		arithmetic: (number1 + number2) / 2,
		geometric: Math.sqrt(number1 * number2),
		harmonic: 2 / (1 / number1 + 1 / number2)
	};
}
			</code></pre>
		</section>

		<section id="arrow-function-parameters">
			<h2>Parametry šipkových funkcí</h2>
			<p>V případě, že má šipková funkce jediný parametr, není jej nutné psát do závorek. Vzhledem k tomu, že ale
				toto platí skutečně pouze pro situaci, kdy má funkce právě jeden parametr, většina lidí jej dá do
				závorek i v tomto případě.</p>
			<pre><code class="language-javascript">
const randomInteger = (minimum, maximum) =&gt; Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
const generalDice = sides =&gt; randomInteger(1, sides);
const traditionalDice = () =&gt; generalDice(6);
			</code></pre>
			<pre><code class="language-javascript">
function randomInteger(minimum, maximum) {
	return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}
function generalDice(sides) {
	return randomInteger(1, sides);
}
function traditionalDice() {
	return generalDice(6);
}
			</code></pre>
		</section>

		<section id="conditional-operator">
			<h2>Podmínkový operátor</h2>
			<p>Kromě podmínkového příkazu (<code>if</code>) v JavaScriptu existuje i podmínkový operátor. Často se o něm
				hovoří jako o ternárním operátoru, což sice technicky vzato vyjadřuje pouze to, že má tři operandy,
				nicméně jelikož je to v JavaScriptu jediný operátor s touto vlastností, vžilo se pro něj toto obecné
				pojmenování. Hodí se v situaci, kdy při splnění určité podmínky potřebujeme použít jednu hodnotu,
				zatímco při jejím nesplnění hodnotu jinou.</p>
			<pre><code class="language-javascript">
const age = Number(prompt("Zadej věk uživatele:"));
const isAdultText = age &gt;= 18 ? "je" : "není";
console.log(`Uživatel ${isAdultText} plnoletý.`);
// alternative, even shorter possibility:
console.log(`Uživatel ${age &gt;= 18 ? "je" : "není"} plnoletý.`);
			</code></pre>
			<pre><code class="language-javascript">
const age = Number(prompt("Zadej věk uživatele:"));
let isAdultText;
if (age &gt;= 18) {
	isAdultText = "je";
} else {
	isAdultText = "není";
}
console.log(`Uživatel ${isAdultText} plnoletý.`);
			</code></pre>
		</section>

		<section id="default-parameter-value">
			<h2>Výchozí hodnoty parametrů funkcí</h2>
			<p>Pokud funkci při volání předáme méně hodnot, než je jejích parametrů, ostatní parametry budou mít hodnotu
				<code>undefined</code>. Můžeme ovšem i určit, že určité parametry mají v takové situaci mít hodnotu
				jinou.</p>
			<pre><code class="language-javascript">
function randomInteger(minimum, maximum) {
	return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}
function dice(sides = 6) {
	return randomInteger(1, sides);
}
console.log(dice());
console.log(dice(10));
			</code></pre>
			<pre><code class="language-javascript">
function randomInteger(minimum, maximum) {
	return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}
function dice(sides) {
	return randomInteger(1, sides !== undefined ? sides : 6);
}
console.log(dice());
console.log(dice(10));
			</code></pre>
		</section>

		<section id="destructuring-function-parameters">
			<h2>Destrukturalizace parametrů funkcí</h2>
			<p>Je-li parametrem funkce objekt (případně pole), můžeme provést destrukturalizaci tohoto parametru rovnou
				v hlavičce funkce. Tato možnost se často hodí například u funkcí, které jsou reactovými komponentami.</p>
			<pre><code class="language-javascript">
const User = ({firstName, lastName, age}) =&gt; {
	// do something with firstName, lastName, and age
}
			</code></pre>
			<pre><code class="language-javascript">
const User = (props) =&gt; {
	const {firstName, lastName, age} = props;
	// do something with firstName, lastName, and age
}
			</code></pre>
		</section>

		<script src="prism.js"></script>
	</body>
</html>
